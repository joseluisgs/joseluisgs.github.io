(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{658:function(e,a,n){"use strict";n.r(a);var r=n(15),o=Object(r.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Las "),n("strong",[e._v("Estructuras de Almacenamiento Estáticas")]),e._v(" son la columna vertebral de la programación. En esta unidad, nos adentraremos en el manejo eficiente de datos mediante estructuras de tamaño fijo, centrándonos en los "),n("strong",[e._v("Arrays")]),e._v(" (vectores y matrices), la gestión avanzada de "),n("strong",[e._v("Cadenas de Texto")]),e._v(" y, finalmente, explorando los fundamentos de los "),n("strong",[e._v("Algoritmos de Ordenación y Búsqueda")]),e._v(" que nos permiten manipular y consultar estos datos.")]),e._v(" "),n("p",[e._v("Comprender la "),n("strong",[e._v("inmutabilidad")]),e._v(" y el modelo de "),n("strong",[e._v("paso por referencia")]),e._v(" de estas estructuras en el lenguaje DAW es esencial para evitar errores comunes y escribir código robusto.")]),e._v(" "),n("h2",{attrs:{id:"_1-arrays-la-base-del-almacenamiento-estatico"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-arrays-la-base-del-almacenamiento-estatico"}},[e._v("#")]),e._v(" 1. Arrays: La Base del Almacenamiento Estático")]),e._v(" "),n("p",[e._v("Un "),n("strong",[e._v("array")]),e._v(" es una estructura de datos fundamental que almacena una colección ordenada de elementos del "),n("strong",[e._v("mismo tipo")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"_1-1-caracteristicas-clave"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-caracteristicas-clave"}},[e._v("#")]),e._v(" 1.1. Características Clave")]),e._v(" "),n("p",[e._v("Los arrays en DAW son estructuras de datos muy eficientes, caracterizadas por:")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Homogeneidad (Tipo Fijo):")]),e._v(" Todos los elementos son del mismo tipo de dato.")]),e._v(" "),n("li",[n("strong",[e._v("Tamaño Fijo (Inmutabilidad):")]),e._v(" El tamaño se establece al crearse y no puede alterarse. Si se requiere un tamaño diferente, se debe crear un "),n("strong",[e._v("nuevo array")]),e._v(" y "),n("strong",[e._v("copiar")]),e._v(" los datos.")]),e._v(" "),n("li",[n("strong",[e._v("Contigüidad en Memoria:")]),e._v(" Los elementos se almacenan en posiciones de memoria contiguas, lo que garantiza su alta eficiencia.")]),e._v(" "),n("li",[n("strong",[e._v("Acceso por Índice:")]),e._v(" El acceso a cualquier elemento se realiza mediante su índice, proporcionando un tiempo de acceso constante ($O(1)$).")])]),e._v(" "),n("h3",{attrs:{id:"_1-2-indexacion-y-tipos-de-referencia"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-indexacion-y-tipos-de-referencia"}},[e._v("#")]),e._v(" 1.2. Indexación y Tipos de Referencia")]),e._v(" "),n("p",[e._v("En el lenguaje DAW, la indexación es "),n("strong",[e._v("Cero-basada")]),e._v(", es decir, el primer elemento se encuentra en el índice "),n("code",[e._v("0")]),e._v(". Acceder a un índice fuera de los límites (negativo o mayor/igual al tamaño) produce una excepción ("),n("code",[e._v("ArrayIndexOutOfBoundsException")]),e._v(").")]),e._v(" "),n("p",[e._v("Crucialmente, los arrays son "),n("strong",[e._v("Tipos de Referencia")]),e._v(" en DAW. Esto implica que:")]),e._v(" "),n("ul",[n("li",[e._v("Al pasar un array a una función, se pasa una "),n("strong",[e._v("copia de su dirección de memoria")]),e._v(" (referencia).")]),e._v(" "),n("li",[e._v("Cualquier modificación a los elementos dentro de la función afecta al array "),n("strong",[e._v("original")]),e._v(".")]),e._v(" "),n("li",[e._v("Para obtener una copia verdaderamente independiente, se debe realizar una "),n("strong",[e._v("Clonación Manual")]),e._v(" (copia profunda), creando un nuevo array y copiando los valores elemento por elemento.")])]),e._v(" "),n("h2",{attrs:{id:"_2-arrays-multidimensionales-matrices-y-tecnicas-avanzadas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-arrays-multidimensionales-matrices-y-tecnicas-avanzadas"}},[e._v("#")]),e._v(" 2. Arrays Multidimensionales (Matrices) y Técnicas Avanzadas")]),e._v(" "),n("p",[e._v("Los arrays multidimensionales (matrices) extienden el concepto del array unidimensional para manejar estructuras de datos con múltiples dimensiones, como tablas o rejillas (filas y columnas).")]),e._v(" "),n("h3",{attrs:{id:"_2-1-gestion-de-la-identidad-y-clonacion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-gestion-de-la-identidad-y-clonacion"}},[e._v("#")]),e._v(" 2.1. Gestión de la Identidad y Clonación")]),e._v(" "),n("p",[e._v("En las matrices, el concepto de referencia se vuelve más complejo.")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Identidad ("),n("code",[e._v("==")]),e._v(")")]),e._v(": El operador "),n("code",[e._v("==")]),e._v(" solo compara si dos matrices apuntan a la "),n("strong",[e._v("misma dirección de memoria")]),e._v(" (Identidad), no si tienen el mismo contenido.")]),e._v(" "),n("li",[n("strong",[e._v("Clonación Profunda")]),e._v(": Una simple asignación o copia superficial resulta en una "),n("strong",[e._v("doble referencia")]),e._v(". Para obtener una copia realmente independiente de una matriz, se requiere una "),n("strong",[e._v("Clonación Profunda Manual")]),e._v(", que implica copiar tanto las referencias de las filas como los valores internos de cada elemento.")])]),e._v(" "),n("h3",{attrs:{id:"_2-2-doble-bufer-double-buffering"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-doble-bufer-double-buffering"}},[e._v("#")]),e._v(" 2.2. Doble Búfer ("),n("code",[e._v("Double Buffering")]),e._v(")")]),e._v(" "),n("p",[e._v("El "),n("code",[e._v("Double Buffering")]),e._v(" es una técnica avanzada esencial para la simulación y la animación.")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Teoría")]),e._v(": Consiste en usar dos matrices ("),n("strong",[e._v("búfer frontal")]),e._v(" y "),n("strong",[e._v("búfer trasero")]),e._v("). Mientras el búfer frontal se muestra al usuario, los cálculos y modificaciones se aplican en el búfer trasero.")]),e._v(" "),n("li",[n("strong",[e._v("Eficiencia")]),e._v(": Una vez completado el cálculo, el "),n("strong",[e._v("mecanismo de intercambio ("),n("code",[e._v("Swap")]),e._v(")")]),e._v(" simplemente intercambia las referencias (punteros) de los dos búferes. Esta operación es de "),n("strong",[e._v("tiempo constante")]),e._v(" ($O(1)$), mucho más eficiente que copiar todos los datos (que sería $O(n^2)$).")])]),e._v(" "),n("h2",{attrs:{id:"_3-cadenas-de-texto-string-y-expresiones-regulares"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-cadenas-de-texto-string-y-expresiones-regulares"}},[e._v("#")]),e._v(" 3. Cadenas de Texto ("),n("code",[e._v("string")]),e._v(") y Expresiones Regulares")]),e._v(" "),n("p",[e._v("Las cadenas de texto son, fundamentalmente, arrays de caracteres, pero con una característica crucial: la "),n("strong",[e._v("inmutabilidad")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"_3-1-inmutabilidad-y-rendimiento-con-stringbuilder"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-inmutabilidad-y-rendimiento-con-stringbuilder"}},[e._v("#")]),e._v(" 3.1. Inmutabilidad y Rendimiento con "),n("code",[e._v("StringBuilder")])]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Inmutabilidad")]),e._v(": Una vez que una cadena ("),n("code",[e._v("string")]),e._v(") se ha creado, no puede ser modificada. Cada operación de concatenación ("),n("code",[e._v("+")]),e._v(") o modificación crea una "),n("strong",[e._v("nueva cadena")]),e._v(" en memoria.")]),e._v(" "),n("li",[n("strong",[e._v("Rendimiento")]),e._v(": Para operaciones intensivas de manipulación o concatenación de texto, el uso repetido del operador "),n("code",[e._v("+")]),e._v(" es ineficiente.")]),e._v(" "),n("li",[n("strong",[n("code",[e._v("StringBuilder")])]),e._v(": Es una clase diseñada para construir cadenas de manera "),n("strong",[e._v("mutable")]),e._v(". Almacena la cadena internamente y solo crea el objeto "),n("code",[e._v("string")]),e._v(" final cuando se solicita, optimizando el rendimiento.")])]),e._v(" "),n("h3",{attrs:{id:"_3-2-expresiones-regulares-regex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-expresiones-regulares-regex"}},[e._v("#")]),e._v(" 3.2. Expresiones Regulares ("),n("code",[e._v("Regex")]),e._v(")")]),e._v(" "),n("p",[e._v("Las expresiones regulares son secuencias de caracteres que definen un patrón de búsqueda.")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Funcionalidad")]),e._v(": Se usan para tareas como la "),n("strong",[e._v("validación")]),e._v(" de formatos (ej. email, DNI), la "),n("strong",[e._v("búsqueda")]),e._v(" de patrones complejos y la "),n("strong",[e._v("sustitución")]),e._v(" de texto.")]),e._v(" "),n("li",[n("strong",[e._v("Conceptos Clave")]),e._v(": Se basan en "),n("strong",[e._v("metacaracteres")]),e._v(" que representan conjuntos de caracteres o cuantificadores (ej. "),n("code",[e._v(".")]),e._v(" para cualquier carácter, "),n("code",[e._v("+")]),e._v(" para una o más ocurrencias).")])]),e._v(" "),n("h2",{attrs:{id:"_4-algoritmos-de-ordenacion-sorting-y-busqueda-searching"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-algoritmos-de-ordenacion-sorting-y-busqueda-searching"}},[e._v("#")]),e._v(" 4. Algoritmos de Ordenación ("),n("code",[e._v("Sorting")]),e._v(") y Búsqueda ("),n("code",[e._v("Searching")]),e._v(")")]),e._v(" "),n("h3",{attrs:{id:"_4-1-algoritmos-de-ordenacion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-algoritmos-de-ordenacion"}},[e._v("#")]),e._v(" 4.1. Algoritmos de Ordenación")]),e._v(" "),n("p",[e._v("La ordenación es el proceso de organizar los elementos de una colección siguiendo un orden específico (ascendente o descendente).")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Burbuja ("),n("code",[e._v("Bubble Sort")]),e._v(")")]),e._v(": Intercambia pares de elementos adyacentes si están en el orden incorrecto. Es simple pero ineficiente ($O(n^2)$).")]),e._v(" "),n("li",[n("strong",[e._v("Selección ("),n("code",[e._v("Selection Sort")]),e._v(")")]),e._v(": Encuentra repetidamente el elemento mínimo (o máximo) y lo coloca en la posición inicial no ordenada. También ineficiente ($O(n^2)$).")]),e._v(" "),n("li",[n("strong",[e._v("Inserción ("),n("code",[e._v("Insertion Sort")]),e._v(")")]),e._v(": Construye la matriz final un elemento a la vez, insertando el elemento actual en su posición correcta dentro de la sub-matriz ya ordenada.")]),e._v(" "),n("li",[n("strong",[e._v("Rápida ("),n("code",[e._v("QuickSort")]),e._v(")")]),e._v(': Utiliza una estrategia de "divide y vencerás". Elige un elemento pivote y particiona la matriz en dos sub-arrays, con los elementos menores al pivote en un lado y los mayores en el otro. Es el método más rápido en promedio ($O(n \\log n)$).')])]),e._v(" "),n("h3",{attrs:{id:"_4-2-algoritmos-de-busqueda"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-algoritmos-de-busqueda"}},[e._v("#")]),e._v(" 4.2. Algoritmos de Búsqueda")]),e._v(" "),n("p",[e._v("La búsqueda es el proceso de encontrar la ubicación de un elemento dentro de una colección.")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Búsqueda Lineal ("),n("code",[e._v("Linear Search")]),e._v(")")]),e._v(": Recorre la colección elemento por elemento hasta encontrar el valor deseado. Funciona en cualquier array, pero es lento ($O(n)$).")]),e._v(" "),n("li",[n("strong",[e._v("Búsqueda Binaria ("),n("code",[e._v("Binary Search")]),e._v(")")]),e._v(": Requiere que la colección esté "),n("strong",[e._v("ordenada")]),e._v(". Divide repetidamente a la mitad el intervalo de búsqueda. Es extremadamente rápida ($O(\\log n)$).")])]),e._v(" "),n("hr"),e._v(" "),n("h2",{attrs:{id:"enlaces-de-interes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#enlaces-de-interes"}},[e._v("#")]),e._v(" Enlaces de interés:")]),e._v(" "),n("p",[n("strong",[e._v("Podcast")])]),e._v(" "),n("p",{staticStyle:{"text-align":"center"}},[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/rQ4tlnVeTYQ",frameborder:"0",allowfullscreen:""}})]),e._v(" "),n("p",[n("strong",[e._v("Resumen del tema")])]),e._v(" "),n("p",{staticStyle:{"text-align":"center"}},[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/092HimAhjog",frameborder:"0",allowfullscreen:""}})]),e._v(" "),n("p",[n("strong",[e._v("Vídeo: Arrays")])]),e._v(" "),n("p",{staticStyle:{"text-align":"center"}},[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/K9n_Plv0CYU",frameborder:"0",allowfullscreen:""}})]),e._v(" "),n("p",[n("strong",[e._v("Vídeo: Strings")])]),e._v(" "),n("p",{staticStyle:{"text-align":"center"}},[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/fTFaNeDxgvU",frameborder:"0",allowfullscreen:""}})]),e._v(" "),n("p",[n("strong",[e._v("Vídeo: Algoritmos de Ordenación y Búsqueda")])]),e._v(" "),n("p",{staticStyle:{"text-align":"center"}},[n("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/_z3R-pQSD50",frameborder:"0",allowfullscreen:""}})]),e._v(" "),n("p",[n("strong",[e._v("Link al repositorio del módulo:")]),e._v(" "),n("a",{attrs:{href:"https://github.com/joseluisgs/Programacion-03-2025-2026",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/joseluisgs/Programacion-03-2025-2026"),n("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=o.exports}}]);